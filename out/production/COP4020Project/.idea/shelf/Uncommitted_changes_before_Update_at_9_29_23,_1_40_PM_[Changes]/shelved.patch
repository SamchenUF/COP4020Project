Index: edu/ufl/cise/cop4020fa23/ExpressionParser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*Copyright 2023 by Beverly A Sanders\n * \n * This code is provided for solely for use of students in COP4020 Programming Language Concepts at the \n * University of Florida during the fall semester 2023 as part of the course project.  \n * \n * No other use is authorized. \n * \n * This code may not be posted on a public web site either during or after the course.  \n */\npackage edu.ufl.cise.cop4020fa23;\n\nimport static edu.ufl.cise.cop4020fa23.Kind.AND;\nimport static edu.ufl.cise.cop4020fa23.Kind.BANG;\nimport static edu.ufl.cise.cop4020fa23.Kind.BITAND;\nimport static edu.ufl.cise.cop4020fa23.Kind.BITOR;\nimport static edu.ufl.cise.cop4020fa23.Kind.COLON;\nimport static edu.ufl.cise.cop4020fa23.Kind.COMMA;\nimport static edu.ufl.cise.cop4020fa23.Kind.DIV;\nimport static edu.ufl.cise.cop4020fa23.Kind.EOF;\nimport static edu.ufl.cise.cop4020fa23.Kind.EQ;\nimport static edu.ufl.cise.cop4020fa23.Kind.EXP;\nimport static edu.ufl.cise.cop4020fa23.Kind.GE;\nimport static edu.ufl.cise.cop4020fa23.Kind.GT;\nimport static edu.ufl.cise.cop4020fa23.Kind.IDENT;\nimport static edu.ufl.cise.cop4020fa23.Kind.LE;\nimport static edu.ufl.cise.cop4020fa23.Kind.LPAREN;\nimport static edu.ufl.cise.cop4020fa23.Kind.LSQUARE;\nimport static edu.ufl.cise.cop4020fa23.Kind.LT;\nimport static edu.ufl.cise.cop4020fa23.Kind.MINUS;\nimport static edu.ufl.cise.cop4020fa23.Kind.MOD;\nimport static edu.ufl.cise.cop4020fa23.Kind.NUM_LIT;\nimport static edu.ufl.cise.cop4020fa23.Kind.OR;\nimport static edu.ufl.cise.cop4020fa23.Kind.PLUS;\nimport static edu.ufl.cise.cop4020fa23.Kind.QUESTION;\nimport static edu.ufl.cise.cop4020fa23.Kind.RARROW;\nimport static edu.ufl.cise.cop4020fa23.Kind.RES_blue;\nimport static edu.ufl.cise.cop4020fa23.Kind.RES_green;\nimport static edu.ufl.cise.cop4020fa23.Kind.RES_height;\nimport static edu.ufl.cise.cop4020fa23.Kind.RES_red;\nimport static edu.ufl.cise.cop4020fa23.Kind.RES_width;\nimport static edu.ufl.cise.cop4020fa23.Kind.RPAREN;\nimport static edu.ufl.cise.cop4020fa23.Kind.RSQUARE;\nimport static edu.ufl.cise.cop4020fa23.Kind.STRING_LIT;\nimport static edu.ufl.cise.cop4020fa23.Kind.TIMES;\nimport static edu.ufl.cise.cop4020fa23.Kind.CONST;\n\nimport java.util.Arrays;\n\nimport edu.ufl.cise.cop4020fa23.ast.AST;\nimport edu.ufl.cise.cop4020fa23.ast.BinaryExpr;\nimport edu.ufl.cise.cop4020fa23.ast.BooleanLitExpr;\nimport edu.ufl.cise.cop4020fa23.ast.ChannelSelector;\nimport edu.ufl.cise.cop4020fa23.ast.ConditionalExpr;\nimport edu.ufl.cise.cop4020fa23.ast.ConstExpr;\nimport edu.ufl.cise.cop4020fa23.ast.ExpandedPixelExpr;\nimport edu.ufl.cise.cop4020fa23.ast.Expr;\nimport edu.ufl.cise.cop4020fa23.ast.IdentExpr;\nimport edu.ufl.cise.cop4020fa23.ast.NumLitExpr;\nimport edu.ufl.cise.cop4020fa23.ast.PixelSelector;\nimport edu.ufl.cise.cop4020fa23.ast.PostfixExpr;\nimport edu.ufl.cise.cop4020fa23.ast.StringLitExpr;\nimport edu.ufl.cise.cop4020fa23.ast.UnaryExpr;\nimport edu.ufl.cise.cop4020fa23.exceptions.LexicalException;\nimport edu.ufl.cise.cop4020fa23.exceptions.PLCCompilerException;\nimport edu.ufl.cise.cop4020fa23.exceptions.SyntaxException;\n/**\nExpr::=  ConditionalExpr | LogicalOrExpr    \nConditionalExpr ::=  ?  Expr  :  Expr  :  Expr \nLogicalOrExpr ::= LogicalAndExpr (    (   |   |   ||   ) LogicalAndExpr)*\nLogicalAndExpr ::=  ComparisonExpr ( (   &   |  &&   )  ComparisonExpr)*\nComparisonExpr ::= PowExpr ( (< | > | == | <= | >=) PowExpr)*\nPowExpr ::= AdditiveExpr ** PowExpr |   AdditiveExpr\nAdditiveExpr ::= MultiplicativeExpr ( ( + | -  ) MultiplicativeExpr )*\nMultiplicativeExpr ::= UnaryExpr (( * |  /  |  % ) UnaryExpr)*\nUnaryExpr ::=  ( ! | - | length | width) UnaryExpr  |  UnaryExprPostfix\nUnaryExprPostfix::= PrimaryExpr (PixelSelector | ε ) (ChannelSelector | ε )\nPrimaryExpr ::=STRING_LIT | NUM_LIT |  IDENT | ( Expr ) | Z \n    ExpandedPixel  \nChannelSelector ::= : red | : green | : blue\nPixelSelector  ::= [ Expr , Expr ]\nExpandedPixel ::= [ Expr , Expr , Expr ]\nDimension  ::=  [ Expr , Expr ]                         \n\n */\n\npublic class ExpressionParser implements IParser {\n\t\n\tfinal ILexer lexer;\n\tprivate IToken t;\n\t\n\n\t/**\n\t * @param lexer\n\t * @throws LexicalException \n\t */\n\tpublic ExpressionParser(ILexer lexer) throws LexicalException {\n\t\tsuper();\n\t\tthis.lexer = lexer;\n\t\tt = lexer.next();\n\t}\n\n\n\t@Override\n\tpublic AST parse() throws PLCCompilerException {\n\t\tExpr e = expr();\n\t\treturn e;\n\t}\n\n\n\tprivate Expr expr() throws PLCCompilerException {\n\t\tIToken firstToken = t;\n\t\tthrow new UnsupportedOperationException(\"THE PARSER HAS NOT BEEN IMPLEMENTED YET\");\n\t}\n\n    \n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/edu/ufl/cise/cop4020fa23/ExpressionParser.java b/edu/ufl/cise/cop4020fa23/ExpressionParser.java
--- a/edu/ufl/cise/cop4020fa23/ExpressionParser.java	
+++ b/edu/ufl/cise/cop4020fa23/ExpressionParser.java	
@@ -43,6 +43,7 @@
 import static edu.ufl.cise.cop4020fa23.Kind.STRING_LIT;
 import static edu.ufl.cise.cop4020fa23.Kind.TIMES;
 import static edu.ufl.cise.cop4020fa23.Kind.CONST;
+import static edu.ufl.cise.cop4020fa23.Kind.BOOLEAN_LIT;
 
 import java.util.Arrays;
 
@@ -84,21 +85,28 @@
  */
 
 public class ExpressionParser implements IParser {
-	
+
 	final ILexer lexer;
 	private IToken t;
-	
 
-	/**
-	 * @param lexer
-	 * @throws LexicalException 
-	 */
 	public ExpressionParser(ILexer lexer) throws LexicalException {
 		super();
 		this.lexer = lexer;
 		t = lexer.next();
 	}
 
+	protected boolean match(Kind kind) {
+		return t.kind() == kind;
+	}
+
+	protected boolean match(Kind... kinds) {
+		for (Kind k : kinds) {
+			if (k == t.kind()) {
+				return true;
+			}
+		}
+		return false;
+	}
 
 	@Override
 	public AST parse() throws PLCCompilerException {
@@ -106,12 +114,88 @@
 		return e;
 	}
 
-
 	private Expr expr() throws PLCCompilerException {
 		IToken firstToken = t;
-		throw new UnsupportedOperationException("THE PARSER HAS NOT BEEN IMPLEMENTED YET");
+		return primaryExpr(firstToken);
 	}
 
-    
+	private Expr primaryExpr(IToken firstToken) throws PLCCompilerException {
+		if (match(STRING_LIT)) {
+			t = lexer.next();
+			return new StringLitExpr(firstToken);
+		}
+		else if (match(NUM_LIT)) {
+			t = lexer.next();
+			return new NumLitExpr(firstToken);
+		}
+		else if(match(BOOLEAN_LIT)) {
+			t = lexer.next();
+			return new BooleanLitExpr(firstToken);
+		}
+		else if (match(IDENT)) {
+			t = lexer.next();
+			return new IdentExpr(firstToken);
+		}
+		else if (match(CONST)) {
+			t = lexer.next();
+			return new ConstExpr(firstToken);
+		}
+		else if (match(LPAREN)) {
+			t = lexer.next();
+			Expr e = expr();
+			if (match(RPAREN)) {
+				t = lexer.next();
+				return e;
+			} else {
+				throw new PLCCompilerException("Expected closing parenthesis after expression", t.sourceLocation());
+			}
+		} else if (match(MINUS, BANG)) {
+			IToken opToken = t;
+			t = lexer.next();
+			Expr e = primaryExpr(t);
+			return new UnaryExpr(firstToken, opToken, e);
+		} else if (match(AT)) {
+			t = lexer.next();
+			if (match(IDENT)) {
+				return new ConstExpr(firstToken);
+			}
+		}
+		throw new UnsupportedOperationException("Unexpected token encountered while parsing expression: " + t.kind());
+	}
+
+	private PixelSelector pixelSelector() throws PLCCompilerException {
+		IToken firstToken = t;
+		if (match(LSQUARE)) {
+			t = lexer.next();
+			Expr xExpr = expr();
+			if (match(COMMA)) {
+				t = lexer.next();
+				Expr yExpr = expr();
+				if (match(RSQUARE)) {
+					t = lexer.next();
+					return new PixelSelector(firstToken, xExpr, yExpr);
+				} else {
+					throw new PLCCompilerException("Expected ']' at pixel selector", t.sourceLocation());
+				}
+			} else {
+				throw new PLCCompilerException("Expected ',' in pixel selector", t.sourceLocation());
+			}
+		}
+		throw new PLCCompilerException("Expected '[' to start a pixel selector", t.sourceLocation());
+	}
 
+	private ChannelSelector channelSelector() throws PLCCompilerException {
+		IToken firstToken = t;
+		if (match(DOT)) {
+			t = lexer.next();
+			if (match(RED, GREEN, BLUE)) {
+				IToken channelToken = t;
+				t = lexer.next();
+				return new ChannelSelector(firstToken, channelToken);
+			} else {
+				throw new PLCCompilerException("Expected a channel (r, g, b) after '.'", t.sourceLocation());
+			}
+		}
+		throw new PLCCompilerException("Expected '.' to start a channel selector", t.sourceLocation());
+	}
 }
